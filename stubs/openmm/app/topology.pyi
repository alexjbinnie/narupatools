# This file is part of narupatools (https://github.com/alexjbinnie/narupatools).
# Copyright (c) Alex Jamieson-Binnie. All rights reserved.
#
# narupatools is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# narupatools is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with narupatools.  If not, see <http://www.gnu.org/licenses/>.

from collections import namedtuple
from os import PathLike
from typing import IO, Iterable, Optional, Sequence, Union

import numpy as np
from simtk.openmm.app import Element
from simtk.unit import Quantity

class _Single: ...
class _Double: ...
class _Triple: ...
class _Aromatic: ...
class _Amide: ...

Single: _Single
Double: _Double
Triple: _Triple
Aromatic: _Aromatic
Amide: _Amide

BondType = Union[_Single, _Double, _Triple, _Aromatic, _Amide]

FloatArray = Union[np.ndarray, Sequence[float]]
FloatArray2D = Union[np.ndarray, Sequence[Sequence[float]]]

class Topology:
    def getNumAtoms(self) -> int: ...
    def getNumResidues(self) -> int: ...
    def getNumChains(self) -> int: ...
    def getNumBonds(self) -> int: ...
    def addChain(self, id: Optional[str] = ...) -> Chain: ...
    def addResidue(
        self, name: str, chain: Chain, id: Optional[str] = ..., insertionCode: str = ...
    ) -> Residue: ...
    def addAtom(
        self, name: str, element: Element, residue: Residue, id: Optional[str] = ...
    ) -> Atom: ...
    def addBond(
        self,
        atom1: Atom,
        atom2: Atom,
        type: Optional[BondType] = ...,
        order: Optional[int] = ...,
    ) -> None: ...
    def chains(self) -> Iterable[Chain]: ...
    def residues(self) -> Iterable[Residue]: ...
    def atoms(self) -> Iterable[Atom]: ...
    def bonds(self) -> Iterable[Bond]: ...
    def getPeriodicBoxVectors(self) -> Optional[Quantity[FloatArray2D]]: ...
    def setPeriodicBoxVectors(
        self, vectors: Optional[Union[FloatArray2D, Quantity[FloatArray2D]]]
    ) -> None: ...
    def getUnitCellDimensions(self) -> Optional[Quantity[FloatArray]]: ...
    def setUnitCellDimensions(
        self, dimensions: Optional[Union[FloatArray, Quantity[FloatArray]]]
    ) -> None: ...
    @staticmethod
    def loadBondDefinitions(file: Union[str, bytes, PathLike, IO]) -> None: ...
    def createStandardBonds(self) -> None: ...
    def createDisulfideBonds(
        self, positions: Union[FloatArray, Quantity[FloatArray]]
    ) -> None: ...

class Chain:
    id: str
    topology: Topology
    index: int
    def residues(self) -> Iterable[Residue]: ...
    def atoms(self) -> Iterable[Atom]: ...
    def __len__(self) -> int: ...

class Residue:
    name: str
    index: int
    chain: Chain
    id: str
    insertionCode: str
    def atoms(self) -> Iterable[Atom]: ...
    def bonds(self) -> Iterable[Bond]: ...
    def internal_bonds(self) -> Iterable[Bond]: ...
    def external_bonds(self) -> Iterable[Bond]: ...
    def __len__(self) -> int: ...

class Atom:
    name: str
    element: Element
    index: int
    residue: Residue
    id: str

class Bond(namedtuple("Bond", ["atom1", "atom2"])):
    type: Optional[BondType]
    order: Optional[int]
