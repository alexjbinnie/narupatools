# This file is part of narupatools (https://github.com/alexjbinnie/narupatools).
# Copyright (c) Alex Jamieson-Binnie. All rights reserved.
#
# narupatools is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# narupatools is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with narupatools.  If not, see <http://www.gnu.org/licenses/>.
from typing import Any, Literal, Mapping, NewType, Sequence, Set, Tuple, Union, overload

import numpy as np
from openmm.unit import Quantity
from openmm.vec3 import Vec3

class Force:
    def getForceGroup(self) -> int: ...
    def setForceGroup(self, group: int): ...
    def getName(self) -> str: ...
    def setName(self, name: str) -> None: ...
    def usesPeriodicBoundaryConditions(self) -> bool: ...

class AmoebaGeneralizedKirkwoodForce(Force):
    def __init__(self) -> None: ...
    def addParticle(
        self, charge: float, radius: float, scalingFactor: float
    ) -> int: ...
    def getIncludeCavityTerm(self) -> int: ...
    def getNumParticles(self) -> int: ...
    def getParticleParameters(
        self, index: int
    ) -> Tuple[Quantity[float], Quantity[float], float]: ...
    def getProbeRadius(self) -> Quantity[float]: ...
    def getSoluteDielectric(self) -> float: ...
    def getSolventDielectric(self) -> float: ...
    def getSurfaceAreaFactor(self) -> Quantity[float]: ...
    def setIncludeCavityTerm(self, includeCavityTerm) -> None: ...
    def setParticleParameters(
        self, index: int, charge: float, radius: float, scalingFactor: float
    ) -> None: ...
    def setProbeRadius(self, probeRadius) -> None: ...
    def setSoluteDielectric(self, dielectric) -> None: ...
    def setSolventDielectric(self, dielectric) -> None: ...
    def setSurfaceAreaFactor(self, surfaceAreaFactor) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class AmoebaMultipoleForce(Force):
    NonbondedMethod = NewType("NonbondedMethod", int)
    NoCutoff: NonbondedMethod
    PME: NonbondedMethod
    PolarizationType = NewType("PolarizationType", int)
    Mutual: PolarizationType
    Direct: PolarizationType
    MultipoleAxisTypes = NewType("MultipoleAxisTypes", int)
    ZThenX: MultipoleAxisTypes
    Bisector: MultipoleAxisTypes
    ZBisect: MultipoleAxisTypes
    ThreeFold: MultipoleAxisTypes
    ZOnly: MultipoleAxisTypes
    NoAxisType: MultipoleAxisTypes
    LastAxisTypeIndex: MultipoleAxisTypes
    CovalentType = NewType("CovalentType", int)
    Covalent12: CovalentType
    Covalent13: CovalentType
    Covalent14: CovalentType
    Covalent15: CovalentType
    PolarizationCovalent11: CovalentType
    PolarizationCovalent12: CovalentType
    PolarizationCovalent13: CovalentType
    PolarizationCovalent14: CovalentType
    CovalentEnd: CovalentType
    def __init__(self) -> None: ...
    def addMultipole(
        self,
        charge: float,
        molecularDipole: Sequence[float],
        molecularQuadrupole: Sequence[float],
        axisType: int,
        multipoleAtomZ: int,
        multipoleAtomX: int,
        multipoleAtomY: int,
        thole: float,
        dampingFactor: float,
        polarity: float,
    ) -> int: ...
    def getAEwald(self) -> Quantity[float]: ...
    def getCovalentMap(self, index: int, typeId: CovalentType) -> Sequence[int]: ...
    def getCovalentMaps(self, index: int) -> Sequence[Sequence[int]]: ...
    def getCutoffDistance(self) -> Quantity[float]: ...
    def getElectrostaticPotential(
        self, inputGrid: Sequence[Vec3], context: Context
    ) -> Sequence[float]: ...
    def getEwaldErrorTolerance(self) -> float: ...
    def getExtrapolationCoefficients(self) -> Sequence[float]: ...
    def getInducedDipoles(self, context: Context) -> Sequence[Vec3]: ...
    def getLabFramePermanentDipoles(self, context: Context) -> Sequence[Vec3]: ...
    def getMultipoleParameters(
        self, index: int
    ) -> Tuple[
        Quantity[float],
        Quantity[Sequence[float]],
        Quantity[Sequence[float]],
        int,
        int,
        int,
        int,
        float,
        float,
        Quantity[float],
    ]: ...
    def getMutualInducedMaxIterations(self) -> int: ...
    def getMutualInducedTargetEpsilon(self) -> float: ...
    def getNonbondedMethod(self) -> NonbondedMethod: ...
    def getNumMultipoles(self) -> int: ...
    def getPMEParameters(self) -> Tuple[float, int, int, int]: ...
    def getPMEParametersInContext(
        self, context: Context
    ) -> Tuple[float, int, int, int]: ...
    def getPmeBSplineOrder(self) -> int: ...
    def getPmeGridDimensions(self) -> None: ...
    def getPolarizationType(self) -> PolarizationType: ...
    def getSystemMultipoleMoments(self, context: Context) -> Sequence[float]: ...
    def getTotalDipoles(self, context: Context) -> Sequence[Vec3]: ...
    def setAEwald(self, aewald: float) -> None: ...
    def setCovalentMap(
        self, index: int, typeId: CovalentType, covalentAtoms: Sequence[int]
    ) -> None: ...
    def setCutoffDistance(self, distance: Union[float, Quantity[float]]) -> None: ...
    def setEwaldErrorTolerance(self, tol) -> None: ...
    def setExtrapolationCoefficients(self, coefficients: Sequence[float]) -> None: ...
    def setMultipoleParameters(
        self,
        index: int,
        charge: float,
        molecularDipole: Sequence[float],
        molecularQuadrupole: Sequence[float],
        axisType: int,
        multipoleAtomZ: int,
        multipoleAtomX: int,
        multipoleAtomY: int,
        thole: float,
        dampingFactor: float,
        polarity: float,
    ) -> None: ...
    def setMutualInducedMaxIterations(
        self, inputMutualInducedMaxIterations: int
    ) -> None: ...
    def setMutualInducedTargetEpsilon(
        self, inputMutualInducedTargetEpsilon: float
    ) -> None: ...
    def setNonbondedMethod(self, method: NonbondedMethod) -> None: ...
    def setPMEParameters(self, alpha: float, nx: int, ny: int, nz: int) -> None: ...
    def setPmeGridDimensions(self, gridDimension: Sequence[int]) -> None: ...
    def setPolarizationType(self, type: PolarizationType) -> None: ...
    def updateParametersInContext(self, context: Context) -> None: ...

class AmoebaTorsionTorsionForce(Force):
    def __init__(self) -> None: ...
    def addTorsionTorsion(
        self,
        particle1: int,
        particle2: int,
        particle3: int,
        particle4: int,
        particle5: int,
        chiralCheckAtomIndex: int,
        gridIndex: int,
    ) -> int: ...
    def getNumTorsionTorsionGrids(self) -> int: ...
    def getNumTorsionTorsions(self) -> int: ...
    def getTorsionTorsionGrid(
        self, index: int
    ) -> Sequence[Sequence[Sequence[float]]]: ...
    def getTorsionTorsionParameters(
        self, index: int
    ) -> Tuple[int, int, int, int, int, int, int]: ...
    def setTorsionTorsionGrid(
        self, index: int, grid: Sequence[Sequence[Sequence[float]]]
    ) -> None: ...
    def setTorsionTorsionParameters(
        self,
        index: int,
        particle1: int,
        particle2: int,
        particle3: int,
        particle4: int,
        particle5: int,
        chiralCheckAtomIndex: int,
        gridIndex: int,
    ) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic) -> None: ...

class AmoebaVdwForce(Force):
    NonbondedMethod = NewType("NonbondedMethod", int)
    NoCutoff: NonbondedMethod
    CutoffPeriodic: NonbondedMethod
    PotentialFunction = NewType("PotentialFunction", int)
    Buffered147: PotentialFunction
    LennardJones: PotentialFunction
    AlchemicalMethod = NewType("AlchemicalMethod", int)
    _None: AlchemicalMethod
    Decouple: AlchemicalMethod
    Annihilate: AlchemicalMethod
    @staticmethod
    def Lambda() -> None: ...
    def __init__(self) -> None: ...
    def addParticle(
        self,
        parentIndex: int,
        typeIndex: int,
        reductionFactor: float,
        isAlchemical: bool,
        /,
    ) -> int: ...
    def addParticleType(self, sigma: float, epsilon: float) -> int: ...
    def addTypePair(
        self, type1: int, type2: int, sigma: float, epsilon: float
    ) -> int: ...
    def getAlchemicalMethod(self) -> AlchemicalMethod: ...
    def getCutoff(self) -> Quantity[float]: ...
    def getCutoffDistance(self) -> Quantity[float]: ...
    def getEpsilonCombiningRule(self) -> str: ...
    def getNonbondedMethod(self) -> NonbondedMethod: ...
    def getNumParticleTypes(self) -> int: ...
    def getNumParticles(self) -> int: ...
    def getNumTypePairs(self) -> int: ...
    def getParticleExclusions(self, particleIndex: int) -> Sequence[int]: ...
    def getParticleParameters(
        self, particleIndex: int
    ) -> Tuple[int, Quantity[float], Quantity[float], float, bool, int]: ...
    def getParticleTypeParameters(
        self, typeIndex: int
    ) -> Tuple[Quantity[float], Quantity[float]]: ...
    def getPotentialFunction(self) -> PotentialFunction: ...
    def getSigmaCombiningRule(self) -> str: ...
    def getSoftcoreAlpha(self) -> float: ...
    def getSoftcorePower(self) -> int: ...
    def getTypePairParameters(
        self, pairIndex: int
    ) -> Tuple[int, int, Quantity[float], Quantity[float]]: ...
    def getUseDispersionCorrection(self) -> bool: ...
    def getUseParticleTypes(self) -> bool: ...
    def setAlchemicalMethod(self, method: AlchemicalMethod) -> None: ...
    def setCutoff(self, cutoff) -> None: ...
    def setCutoffDistance(self, distance: Union[float, Quantity[float]]) -> None: ...
    def setEpsilonCombiningRule(self, epsilonCombiningRule: str) -> None: ...
    def setNonbondedMethod(self, method: NonbondedMethod) -> None: ...
    def setParticleExclusions(
        self, particleIndex: int, exclusions: Sequence[int]
    ) -> None: ...
    def setParticleParameters(
        self,
        particleIndex: int,
        parentIndex: int,
        sigma: float,
        epsilon: float,
        reductionFactor: float,
        isAlchemical: bool = ...,
        typeIndex: int = ...,
    ) -> None: ...
    def setParticleTypeParameters(
        self, typeIndex: int, sigma: float, epsilon: float
    ) -> None: ...
    def setPotentialFunction(self, potential) -> None: ...
    def setSigmaCombiningRule(self, sigmaCombiningRule: str) -> None: ...
    def setSoftcoreAlpha(self, alpha) -> None: ...
    def setSoftcorePower(self, n) -> None: ...
    def setTypePairParameters(
        self, pairIndex: int, type1: int, type2: int, sigma: float, epsilon: float
    ) -> None: ...
    def setUseDispersionCorrection(self, useCorrection) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class AmoebaWcaDispersionForce(Force):
    def __init__(self) -> None: ...
    def addParticle(self, radius: float, epsilon: float) -> int: ...
    def getAwater(self) -> Quantity[float]: ...
    def getDispoff(self) -> Quantity[float]: ...
    def getEpsh(self) -> Quantity[float]: ...
    def getEpso(self) -> Quantity[float]: ...
    def getNumParticles(self) -> int: ...
    def getParticleParameters(
        self, particleIndex: int
    ) -> Tuple[Quantity[float], Quantity[float]]: ...
    def getRminh(self) -> Quantity[float]: ...
    def getRmino(self) -> Quantity[float]: ...
    def getShctd(self) -> float: ...
    def getSlevy(self) -> float: ...
    def setAwater(self, inputValue) -> None: ...
    def setDispoff(self, inputValue) -> None: ...
    def setEpsh(self, inputValue) -> None: ...
    def setEpso(self, inputValue) -> None: ...
    def setParticleParameters(
        self, particleIndex: int, radius: float, epsilon: float
    ) -> None: ...
    def setRminh(self, inputValue) -> None: ...
    def setRmino(self, inputValue) -> None: ...
    def setShctd(self, inputValue) -> None: ...
    def setSlevy(self, inputValue) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class AndersenThermostat(Force):
    @staticmethod
    def Temperature() -> str: ...
    @staticmethod
    def CollisionFrequency() -> str: ...
    def getDefaultTemperature(self) -> Quantity[float]: ...
    def setDefaultTemperature(
        self, temperature: Union[float, Quantity[float]]
    ) -> None: ...
    def getDefaultCollisionFrequency(self) -> Quantity[float]: ...
    def setDefaultCollisionFrequency(
        self, frequency: Union[float, Quantity[float]]
    ) -> None: ...
    def getRandomNumberSeed(self) -> int: ...
    def setRandomNumberSeed(self, seed: int) -> None: ...
    def __init__(
        self, defaultTemperature: float, defaultCollisionFrequency: float, /
    ) -> None: ...

class Integrator:
    def getStepSize(self) -> Quantity[float]: ...
    def setStepSize(self, size: Union[float, Quantity[float]]) -> None: ...
    def getConstraintTolerance(self) -> float: ...
    def setConstraintTolerance(self, tol: float) -> None: ...
    def step(self, steps: int) -> None: ...
    def getIntegrationForceGroups(self) -> int: ...
    def setIntegrationForceGroups(self, groups: Union[int, Set[int]]) -> None: ...

class BrownianIntegrator(Integrator):
    def getTemperature(self) -> Quantity[float]: ...
    def setTemperature(self, temp: Union[float, Quantity[float]]) -> None: ...
    def getFriction(self) -> Quantity[float]: ...
    def setFriction(self, coeff: Union[float, Quantity[float]]) -> None: ...
    def getRandomNumberSeed(self) -> int: ...
    def setRandomNumberSeed(self, seed: int) -> None: ...
    def __init__(
        self,
        temperature: Union[float, Quantity[float]],
        frictionCoeff: Union[float, Quantity[float]],
        stepSize: Union[float, Quantity[float]],
        /,
    ) -> None: ...

class CMMotionRemover(Force):
    thisown: Any
    def getFrequency(self) -> int: ...
    def setFrequency(self, freq: int) -> None: ...
    def __init__(self, frequency=..., /) -> None: ...

class CompoundIntegrator(Integrator):
    def getNumIntegrators(self) -> int: ...
    def addIntegrator(self, integrator: Integrator) -> int: ...
    def getIntegrator(self, index: int, /) -> int: ...
    def getCurrentIntegrator(self) -> int: ...
    def setCurrentIntegrator(self, index: int) -> None: ...

class Context:
    def getSystem(self) -> System: ...
    def getPlatform(self) -> Platform: ...
    def setState(self, state: State) -> None: ...
    def setTime(self, time: Union[float, Quantity[float]]) -> None: ...
    def setPositions(
        self, positions: Union[np.ndarray, Quantity[np.ndarray]]
    ) -> None: ...
    def setVelocities(self, velocities: Union[np.ndarray, Quantity[np.ndarray]]): ...
    def setVelocitiesToTemperature(self, temperature, randomSeed=..., /) -> None: ...
    def getParameters(self) -> Mapping[str, float]: ...
    def getParameter(self, name: str) -> float: ...
    def setParameter(self, name: str, value: float) -> None: ...
    def setPeriodicBoxVectors(
        self,
        a: Union[np.ndarray, Quantity[np.ndarray]],
        b: Union[np.ndarray, Quantity[np.ndarray]],
        c: Union[np.ndarray, Quantity[np.ndarray]],
    ) -> None: ...
    def applyConstraints(self, tol: float) -> None: ...
    def applyVelocityConstraints(self, tol: float) -> None: ...
    def computeVirtualSites(self) -> None: ...
    def reinitialize(self, preserveState: bool = ...) -> None: ...
    def getMolecules(self) -> Sequence[Sequence[int]]: ...
    def getIntegrator(self) -> Integrator: ...
    def getState(
        self,
        getPositions: bool = ...,
        getVelocities: bool = ...,
        getForces: bool = ...,
        getEnergy: bool = ...,
        getParameters: bool = ...,
        getParameterDerivatives: bool = ...,
        getIntegratorParameters: bool = ...,
        enforcePeriodicBox: bool = ...,
        groups: Union[int, Set[int]] = ...,
    ) -> State: ...
    def createCheckpoint(self) -> str: ...
    def loadCheckpoint(self, checkpoint: str) -> None: ...
    def __init__(
        self,
        system: System,
        integrator: Integrator,
        platform: Platform = ...,
        properties: Any = ...,
        /,
    ) -> None: ...

class TabulatedFunction:
    def Copy(self) -> TabulatedFunction: ...
    def getPeriodic(self) -> bool: ...

class Continuous1DFunction(TabulatedFunction):
    def __init__(self, values, min, max, periodic: bool = ...) -> None: ...
    def getFunctionParameters(self): ...
    def setFunctionParameters(self, values, min, max): ...
    def Copy(self) -> Continuous1DFunction: ...

class Continuous2DFunction(TabulatedFunction):
    def __init__(
        self, xsize, ysize, values, xmin, xmax, ymin, ymax, periodic: bool = ...
    ) -> None: ...
    def getFunctionParameters(self): ...
    def setFunctionParameters(self, xsize, ysize, values, xmin, xmax, ymin, ymax): ...
    def Copy(self) -> Continuous2DFunction: ...

class Continuous3DFunction(TabulatedFunction):
    def __init__(
        self,
        xsize,
        ysize,
        zsize,
        values,
        xmin,
        xmax,
        ymin,
        ymax,
        zmin,
        zmax,
        periodic: bool = ...,
    ) -> None: ...
    def getFunctionParameters(self): ...
    def setFunctionParameters(
        self, xsize, ysize, zsize, values, xmin, xmax, ymin, ymax, zmin, zmax
    ): ...
    def Copy(self) -> Continuous3DFunction: ...

class CustomAngleForce(Force):
    def getNumAngles(self) -> int: ...
    def getNumPerAngleParameters(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumEnergyParameterDerivatives(self) -> int: ...
    def getEnergyFunction(self) -> str: ...
    def setEnergyFunction(self, energy: str) -> None: ...
    def addPerAngleParameter(self, name: str) -> int: ...
    def getPerAngleParameterName(self, index: int) -> str: ...
    def setPerAngleParameterName(self, index: int, name: str) -> None: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> None: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def addEnergyParameterDerivative(self, name: str) -> int: ...
    def getEnergyParameterDerivativeName(self, index: int) -> str: ...
    def addAngle(
        self,
        particle1: int,
        particle2: int,
        particle3: int,
        parameters: Sequence[float],
    ) -> int: ...
    def getAngleParameters(
        self, index: int
    ) -> Tuple[int, int, int, Sequence[float]]: ...
    def setAngleParameters(
        self,
        index: int,
        particle1: int,
        particle2: int,
        particle3: int,
        parameters: Sequence[float],
    ) -> None: ...
    def updateParametersInContext(self, context: Context) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic: bool) -> None: ...
    def __init__(self, energy: str) -> None: ...

class CustomBondForce(Force):
    def getNumBonds(self) -> int: ...
    def getNumPerBondParameters(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumEnergyParameterDerivatives(self) -> int: ...
    def getEnergyFunction(self) -> str: ...
    def setEnergyFunction(self, energy: str) -> None: ...
    def addPerBondParameter(self, name: str) -> int: ...
    def getPerBondParameterName(self, index: int) -> str: ...
    def setPerBondParameterName(self, index: int, name: str) -> None: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def addEnergyParameterDerivative(self, name: str) -> int: ...
    def getEnergyParameterDerivativeName(self, index: int) -> str: ...
    def addBond(
        self, particle1: int, particle2: int, parameters: Sequence[float]
    ) -> int: ...
    def getBondParameters(self, index: int) -> Tuple[int, int, Sequence[float]]: ...
    def setBondParameters(
        self, index: int, particle1: int, particle2: int, parameters: Sequence[float]
    ) -> None: ...
    def updateParametersInContext(self, context: Context) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic: bool) -> None: ...
    def __init__(self, energy: str, /) -> None: ...

class CustomCentroidBondForce(Force):
    def __init__(self, numGroups: int, energy: str, /) -> None: ...
    def addBond(self, groups: Sequence[int], parameters: Sequence[float], /) -> int: ...
    def addEnergyParameterDerivative(self, name: str) -> None: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def addGroup(
        self, particles: Sequence[int], weights: Sequence[float], /
    ) -> int: ...
    def addPerBondParameter(self, name: str) -> int: ...
    def addTabulatedFunction(self, name: str, function: TabulatedFunction) -> int: ...
    def getBondParameters(
        self, index: int
    ) -> Tuple[Sequence[int], Sequence[float]]: ...
    def getEnergyFunction(self) -> str: ...
    def getEnergyParameterDerivativeName(self, index: int) -> str: ...
    def getForceGroup(self) -> int: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def getGroupParameters(
        self, index: int
    ) -> Tuple[Sequence[int], Sequence[float]]: ...
    def getName(self) -> str: ...
    def getNumBonds(self) -> int: ...
    def getNumEnergyParameterDerivatives(self) -> int: ...
    def getNumFunctions(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumGroups(self) -> int: ...
    def getNumGroupsPerBond(self) -> int: ...
    def getNumPerBondParameters(self) -> int: ...
    def getNumTabulatedFunctions(self) -> int: ...
    def getPerBondParameterName(self, index: int) -> str: ...
    def getTabulatedFunction(self, index: int, /) -> TabulatedFunction: ...
    def getTabulatedFunctionName(self, index: int) -> str: ...
    def setBondParameters(
        self, index: int, groups: Sequence[int], parameters: Sequence[float], /
    ) -> None: ...
    def setEnergyFunction(self, energy) -> None: ...
    def setForceGroup(self, group: int) -> None: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def setGroupParameters(
        self, index: int, particles: Sequence[int], weights: Sequence[float], /
    ) -> None: ...
    def setName(self, name) -> None: ...
    def setPerBondParameterName(self, index: int, name: str) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic) -> None: ...
    def updateParametersInContext(self, context) -> None: ...
    def usesPeriodicBoundaryConditions(self) -> bool: ...

class CustomCompoundBondForce(Force):
    def __init__(self, numParticles: int, energy: str, /) -> None: ...
    def addBond(
        self, particles: Sequence[int], parameters: Sequence[float], /
    ) -> int: ...
    def addEnergyParameterDerivative(self, name: str) -> None: ...
    def addFunction(self, name, values, min, max) -> int: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def addPerBondParameter(self, name: str) -> int: ...
    def addTabulatedFunction(self, name: str, function: TabulatedFunction) -> int: ...
    def getBondParameters(
        self, index: int
    ) -> Tuple[Sequence[int], Sequence[float]]: ...
    def getEnergyFunction(self) -> str: ...
    def getEnergyParameterDerivativeName(self, index: int) -> str: ...
    def getForceGroup(self) -> int: ...
    def getFunctionParameters(self, index) -> None: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def getName(self) -> str: ...
    def getNumBonds(self) -> int: ...
    def getNumEnergyParameterDerivatives(self) -> int: ...
    def getNumFunctions(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumParticlesPerBond(self) -> int: ...
    def getNumPerBondParameters(self) -> int: ...
    def getNumTabulatedFunctions(self) -> int: ...
    def getPerBondParameterName(self, index: int) -> str: ...
    def getTabulatedFunction(self, index: int, /) -> TabulatedFunction: ...
    def getTabulatedFunctionName(self, index: int) -> str: ...
    def setBondParameters(
        self, index: int, particles: Sequence[int], parameters: Sequence[float], /
    ) -> None: ...
    def setEnergyFunction(self, energy) -> None: ...
    def setForceGroup(self, group: int) -> None: ...
    def setFunctionParameters(self, index, name, values, min, max) -> None: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def setName(self, name) -> None: ...
    def setPerBondParameterName(self, index: int, name: str) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic) -> None: ...
    def updateParametersInContext(self, context) -> None: ...
    def usesPeriodicBoundaryConditions(self) -> bool: ...

class CustomCVForce(Force):
    def __init__(self, energy: str, /) -> None: ...
    def addCollectiveVariable(self, name: str, variable: Force) -> int: ...
    def addEnergyParameterDerivative(self, name: str) -> None: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def addTabulatedFunction(self, name: str, function: TabulatedFunction) -> int: ...
    def getCollectiveVariable(self, index: int, /) -> Force: ...
    def getCollectiveVariableName(self, index: int) -> str: ...
    def getCollectiveVariableValues(self, context: Context) -> Sequence[float]: ...
    def getEnergyFunction(self) -> str: ...
    def getEnergyParameterDerivativeName(self, index: int) -> str: ...
    def getForceGroup(self) -> int: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def getInnerContext(self, context: Context) -> Context: ...
    def getName(self) -> str: ...
    def getNumCollectiveVariables(self) -> int: ...
    def getNumEnergyParameterDerivatives(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumTabulatedFunctions(self) -> int: ...
    def getTabulatedFunction(self, index: int, /) -> TabulatedFunction: ...
    def getTabulatedFunctionName(self, index: int) -> str: ...
    def setEnergyFunction(self, energy) -> None: ...
    def setForceGroup(self, group: int) -> None: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def setName(self, name) -> None: ...
    def updateParametersInContext(self, context) -> None: ...
    def usesPeriodicBoundaryConditions(self) -> bool: ...

class CustomExternalForce(Force):
    def __init__(self, energy: str, /) -> None: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def addParticle(self, particle: int, parameters: Sequence[float], /) -> int: ...
    def addPerParticleParameter(self, name: str) -> int: ...
    def getEnergyFunction(self) -> str: ...
    def getForceGroup(self) -> int: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def getName(self) -> str: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumParticles(self) -> int: ...
    def getNumPerParticleParameters(self) -> int: ...
    def getParticleParameters(self, index: int) -> Tuple[int, Sequence[float]]: ...
    def getPerParticleParameterName(self, index: int) -> str: ...
    def setEnergyFunction(self, energy) -> None: ...
    def setForceGroup(self, group: int) -> None: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def setName(self, name) -> None: ...
    def setParticleParameters(
        self, index: int, particle: int, parameters: Sequence[float], /
    ) -> None: ...
    def setPerParticleParameterName(self, index: int, name: str) -> None: ...
    def updateParametersInContext(self, context) -> None: ...
    def usesPeriodicBoundaryConditions(self) -> bool: ...

class CustomGBForce(Force):
    NonbondedMethod = NewType("NonbondedMethod", int)
    ComputationType = NewType("ComputationType", int)
    NoCutoff: NonbondedMethod
    CutoffNonPeriodic: NonbondedMethod
    CutoffPeriodic: NonbondedMethod
    SingleParticle: ComputationType
    ParticlePair: ComputationType
    ParticlePairNoExclusions: ComputationType
    def __init__(self) -> None: ...
    def addComputedValue(
        self, name: str, expression: str, type: ComputationType
    ) -> int: ...
    def addEnergyParameterDerivative(self, name: str) -> None: ...
    def addEnergyTerm(self, expression: str, type: ComputationType) -> int: ...
    def addExclusion(self, particle1: int, particle2: int) -> int: ...
    def addFunction(self, name, values, min, max) -> int: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def addParticle(self, parameters: Sequence[float], /) -> int: ...
    def addPerParticleParameter(self, name: str) -> int: ...
    def addTabulatedFunction(self, name: str, function: TabulatedFunction) -> int: ...
    def getComputedValueParameters(
        self, index: int
    ) -> Tuple[str, str, ComputationType]: ...
    def getCutoffDistance(self) -> float: ...
    def getEnergyParameterDerivativeName(self, index: int) -> str: ...
    def getEnergyTermParameters(self, index: int) -> Tuple[str, ComputationType]: ...
    def getExclusionParticles(self, index: int) -> Tuple[int, int]: ...
    def getForceGroup(self) -> int: ...
    def getFunctionParameters(self, index) -> None: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def getName(self) -> str: ...
    def getNonbondedMethod(self) -> NonbondedMethod: ...
    def getNumComputedValues(self) -> int: ...
    def getNumEnergyParameterDerivatives(self) -> int: ...
    def getNumEnergyTerms(self) -> int: ...
    def getNumExclusions(self) -> int: ...
    def getNumFunctions(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumParticles(self) -> int: ...
    def getNumPerParticleParameters(self) -> int: ...
    def getNumTabulatedFunctions(self) -> int: ...
    def getParticleParameters(self, index: int) -> Sequence[float]: ...
    def getPerParticleParameterName(self, index: int) -> str: ...
    def getTabulatedFunction(self, index: int, /) -> TabulatedFunction: ...
    def getTabulatedFunctionName(self, index: int) -> str: ...
    def setComputedValueParameters(
        self, index: int, name: str, expression: str, type: ComputationType
    ) -> None: ...
    def setCutoffDistance(self, distance: float) -> None: ...
    def setEnergyTermParameters(
        self, index: int, expression: str, type: ComputationType
    ) -> None: ...
    def setExclusionParticles(
        self, index: int, particle1: int, particle2: int
    ) -> None: ...
    def setForceGroup(self, group: int) -> None: ...
    def setFunctionParameters(self, index, name, values, min, max) -> None: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def setName(self, name) -> None: ...
    def setNonbondedMethod(self, method) -> None: ...
    def setParticleParameters(
        self, index: int, parameters: Sequence[float]
    ) -> None: ...
    def setPerParticleParameterName(self, index: int, name: str) -> None: ...
    def updateParametersInContext(self, context) -> None: ...
    def usesPeriodicBoundaryConditions(self) -> bool: ...

class CustomHbondForce(Force):
    NonbondedMethod = NewType("NonbondedMethod", int)
    NoCutoff: NonbondedMethod
    CutoffNonPeriodic: NonbondedMethod
    CutoffPeriodic: NonbondedMethod
    def __init__(self, energy: str, /) -> None: ...
    def addAcceptor(
        self, a1: int, a2: int, a3: int, parameters: Sequence[float], /
    ) -> int: ...
    def addDonor(
        self, d1: int, d2: int, d3: int, parameters: Sequence[float], /
    ) -> int: ...
    def addExclusion(self, donor: int, acceptor: int) -> int: ...
    def addFunction(self, name, values, min, max) -> int: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def addPerAcceptorParameter(self, name: str) -> int: ...
    def addPerDonorParameter(self, name: str) -> int: ...
    def addTabulatedFunction(self, name: str, function: TabulatedFunction) -> int: ...
    def getAcceptorParameters(
        self, index: int
    ) -> Tuple[int, int, int, Sequence[float]]: ...
    def getCutoffDistance(self) -> float: ...
    def getDonorParameters(
        self, index: int
    ) -> Tuple[int, int, int, Sequence[float]]: ...
    def getEnergyFunction(self) -> str: ...
    def getExclusionParticles(self, index: int) -> Tuple[int, int]: ...
    def getForceGroup(self) -> int: ...
    def getFunctionParameters(self, index) -> None: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def getName(self) -> str: ...
    def getNonbondedMethod(self) -> NonbondedMethod: ...
    def getNumAcceptors(self) -> int: ...
    def getNumDonors(self) -> int: ...
    def getNumExclusions(self) -> int: ...
    def getNumFunctions(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumPerAcceptorParameters(self) -> int: ...
    def getNumPerDonorParameters(self) -> int: ...
    def getNumTabulatedFunctions(self) -> int: ...
    def getPerAcceptorParameterName(self, index: int) -> str: ...
    def getPerDonorParameterName(self, index: int) -> str: ...
    def getTabulatedFunction(self, index: int, /) -> TabulatedFunction: ...
    def getTabulatedFunctionName(self, index: int) -> str: ...
    def setAcceptorParameters(
        self, index: int, a1: int, a2: int, a3: int, parameters: Sequence[float], /
    ) -> None: ...
    def setCutoffDistance(self, distance: float) -> None: ...
    def setDonorParameters(
        self, index: int, d1: int, d2: int, d3: int, parameters: Sequence[float], /
    ) -> None: ...
    def setEnergyFunction(self, energy) -> None: ...
    def setExclusionParticles(self, index: int, donor: int, acceptor: int) -> None: ...
    def setForceGroup(self, group: int) -> None: ...
    def setFunctionParameters(self, index, name, values, min, max) -> None: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def setName(self, name) -> None: ...
    def setNonbondedMethod(self, method: NonbondedMethod) -> None: ...
    def setPerAcceptorParameterName(self, index: int, name: str) -> None: ...
    def setPerDonorParameterName(self, index: int, name: str) -> None: ...
    def updateParametersInContext(self, context) -> None: ...
    def usesPeriodicBoundaryConditions(self) -> bool: ...

class CustomIntegrator(Integrator):
    ComputationType = NewType("ComputationType", int)
    ComputeGlobal: ComputationType
    ComputePerDof: ComputationType
    ComputeSum: ComputationType
    ConstrainPositions: ComputationType
    ConstrainVelocities: ComputationType
    UpdateContextState: ComputationType
    def __init__(self, stepSize: Union[float, Quantity[float]], /) -> None: ...
    def addComputeGlobal(self, variable: str, expression: str) -> int: ...
    def addComputePerDof(self, variable: str, expression: str) -> int: ...
    def addComputeSum(self, variable: str, expression: str) -> int: ...
    def addConstrainPositions(self) -> int: ...
    def addConstrainVelocities(self) -> int: ...
    def addGlobalVariable(self, name: str, initialValue: float) -> int: ...
    def addPerDofVariable(self, name: str, initialValue: float) -> int: ...
    def addTabulatedFunction(self, name: str, function: TabulatedFunction) -> int: ...
    def addUpdateContextState(self) -> int: ...
    def beginIfBlock(self, condition: str) -> int: ...
    def beginWhileBlock(self, condition: str) -> int: ...
    def endBlock(self) -> int: ...
    def getComputationStep(self, index: int) -> Tuple[ComputationType, str, str]: ...
    def getConstraintTolerance(self) -> float: ...
    def getGlobalVariable(self, index: int) -> float: ...
    def getGlobalVariableByName(self, name: str) -> float: ...
    def getGlobalVariableName(self, index: int) -> str: ...
    def getIntegrationForceGroups(self) -> int: ...
    def getKineticEnergyExpression(self) -> str: ...
    def getNumComputations(self) -> int: ...
    def getNumGlobalVariables(self) -> int: ...
    def getNumPerDofVariables(self) -> int: ...
    def getNumTabulatedFunctions(self) -> int: ...
    def getPerDofVariable(self) -> None: ...
    def getPerDofVariableByName(self, name: str) -> Sequence[Vec3]: ...
    def getPerDofVariableName(self, index: int) -> str: ...
    def getRandomNumberSeed(self) -> int: ...
    def getTabulatedFunction(self, index: int, /) -> TabulatedFunction: ...
    def getTabulatedFunctionName(self, index: int) -> str: ...
    def setConstraintTolerance(self, tol) -> None: ...
    def setGlobalVariable(self, index: int, value: float) -> None: ...
    def setGlobalVariableByName(self, name: str, value: float) -> None: ...
    def setIntegrationForceGroups(self, groups: Union[int, Set[int]]) -> None: ...
    def setKineticEnergyExpression(self, expression) -> None: ...
    def setPerDofVariable(self, index: int, values: Sequence[Vec3]) -> None: ...
    def setPerDofVariableByName(self, name: str, values: Sequence[Vec3]) -> None: ...
    def setRandomNumberSeed(self, seed) -> None: ...

class CustomManyParticleForce(Force):
    NonbondedMethod = NewType("NonbondedMethod", int)
    NoCutoff: NonbondedMethod
    CutoffNonPeriodic: NonbondedMethod
    CutoffPeriodic: NonbondedMethod
    PermutationMode = NewType("PermutationMode", int)
    SinglePermutation: PermutationMode
    UniqueCentralParticle: PermutationMode
    def __init__(self, particlesPerSet: int, energy: str, /) -> None: ...
    def addExclusion(self, particle1: int, particle2: int) -> int: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def addParticle(self, parameters: Sequence[float], type: int, /) -> int: ...
    def addPerParticleParameter(self, name: str) -> int: ...
    def addTabulatedFunction(self, name: str, function: TabulatedFunction) -> int: ...
    def createExclusionsFromBonds(
        self, bonds: Sequence[Tuple[int, int]], bondCutoff: int
    ) -> None: ...
    def getCutoffDistance(self) -> float: ...
    def getEnergyFunction(self) -> str: ...
    def getExclusionParticles(self, index: int) -> Tuple[int, int]: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def getNonbondedMethod(self) -> NonbondedMethod: ...
    def getNumExclusions(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumParticles(self) -> int: ...
    def getNumParticlesPerSet(self) -> int: ...
    def getNumPerParticleParameters(self) -> int: ...
    def getNumTabulatedFunctions(self) -> int: ...
    def getParticleParameters(self, index: int) -> Tuple[Sequence[float], int]: ...
    def getPerParticleParameterName(self, index: int) -> str: ...
    def getPermutationMode(self) -> PermutationMode: ...
    def getTabulatedFunction(self, index: int, /) -> TabulatedFunction: ...
    def getTabulatedFunctionName(self, index: int) -> str: ...
    def getTypeFilter(self, index: int) -> Set[int]: ...
    def setCutoffDistance(self, distance: float) -> None: ...
    def setEnergyFunction(self, energy) -> None: ...
    def setExclusionParticles(
        self, index: int, particle1: int, particle2: int
    ) -> None: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def setNonbondedMethod(self, method) -> None: ...
    def setParticleParameters(
        self, index: int, parameters: Sequence[float], type: int
    ) -> None: ...
    def setPerParticleParameterName(self, index: int, name: str) -> None: ...
    def setPermutationMode(self, mode) -> None: ...
    def setTypeFilter(self, index: int, types: Set[int]) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class CustomNonbondedForce(Force):
    NonbondedMethod = NewType("NonbondedMethod", int)
    NoCutoff: NonbondedMethod
    CutoffNonPeriodic: NonbondedMethod
    CutoffPeriodic: NonbondedMethod
    def __init__(self, energy: str, /) -> None: ...
    def addEnergyParameterDerivative(self, name: str) -> None: ...
    def addExclusion(self, particle1: int, particle2: int) -> int: ...
    def addFunction(self, name, values, min, max) -> int: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def addInteractionGroup(self, set1: Set[int], set2: Set[int]) -> int: ...
    def addParticle(self, parameters: Sequence[float], /) -> int: ...
    def addPerParticleParameter(self, name: str) -> int: ...
    def addTabulatedFunction(self, name: str, function: TabulatedFunction) -> int: ...
    def createExclusionsFromBonds(
        self, bonds: Sequence[Tuple[int, int]], bondCutoff: int
    ) -> None: ...
    def getCutoffDistance(self) -> float: ...
    def getEnergyFunction(self) -> str: ...
    def getEnergyParameterDerivativeName(self, index: int) -> str: ...
    def getExclusionParticles(self, index: int) -> Tuple[int, int]: ...
    def getFunctionParameters(self, index) -> None: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def getInteractionGroupParameters(
        self, index: int
    ) -> Tuple[Set[int], Set[int]]: ...
    def getNonbondedMethod(self) -> NonbondedMethod: ...
    def getNumEnergyParameterDerivatives(self) -> int: ...
    def getNumExclusions(self) -> int: ...
    def getNumFunctions(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumInteractionGroups(self) -> int: ...
    def getNumParticles(self) -> int: ...
    def getNumPerParticleParameters(self) -> int: ...
    def getNumTabulatedFunctions(self) -> int: ...
    def getParticleParameters(self, index: int) -> Sequence[float]: ...
    def getPerParticleParameterName(self, index: int) -> str: ...
    def getSwitchingDistance(self) -> float: ...
    def getTabulatedFunction(self, index: int, /) -> TabulatedFunction: ...
    def getTabulatedFunctionName(self, index: int) -> str: ...
    def getUseLongRangeCorrection(self) -> bool: ...
    def getUseSwitchingFunction(self) -> bool: ...
    def setCutoffDistance(self, distance: float) -> None: ...
    def setEnergyFunction(self, energy) -> None: ...
    def setExclusionParticles(
        self, index: int, particle1: int, particle2: int
    ) -> None: ...
    def setFunctionParameters(self, index, name, values, min, max) -> None: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def setInteractionGroupParameters(
        self, index: int, set1: Set[int], set2: Set[int]
    ) -> None: ...
    def setNonbondedMethod(self, method) -> None: ...
    def setParticleParameters(
        self, index: int, parameters: Sequence[float]
    ) -> None: ...
    def setPerParticleParameterName(self, index: int, name: str) -> None: ...
    def setSwitchingDistance(self, distance) -> None: ...
    def setUseLongRangeCorrection(self, use) -> None: ...
    def setUseSwitchingFunction(self, use) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class CustomTorsionForce(Force):
    def __init__(self, energy: str, /) -> None: ...
    def addEnergyParameterDerivative(self, name: str) -> None: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def addPerTorsionParameter(self, name: str) -> int: ...
    def addTorsion(
        self,
        particle1: int,
        particle2: int,
        particle3: int,
        particle4: int,
        parameters: Sequence[float],
        /,
    ) -> int: ...
    def getEnergyFunction(self) -> str: ...
    def getEnergyParameterDerivativeName(self, index: int) -> str: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def getNumEnergyParameterDerivatives(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumPerTorsionParameters(self) -> int: ...
    def getNumTorsions(self) -> int: ...
    def getPerTorsionParameterName(self, index: int) -> str: ...
    def getTorsionParameters(
        self, index: int
    ) -> Tuple[int, int, int, int, Sequence[float]]: ...
    def setEnergyFunction(self, energy) -> None: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def setPerTorsionParameterName(self, index: int, name: str) -> None: ...
    def setTorsionParameters(
        self,
        index: int,
        particle1: int,
        particle2: int,
        particle3: int,
        particle4: int,
        parameters: Sequence[float],
        /,
    ) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class Discrete1DFunction(TabulatedFunction):
    def __init__(self, values) -> None: ...
    def getFunctionParameters(self): ...
    def setFunctionParameters(self, values): ...

class Discrete2DFunction(TabulatedFunction):
    def __init__(self, xsize, ysize, values) -> None: ...
    def getFunctionParameters(self): ...
    def setFunctionParameters(self, xsize, ysize, values): ...

class Discrete3DFunction(TabulatedFunction):
    def __init__(self, xsize, ysize, zsize, values) -> None: ...
    def getFunctionParameters(self): ...
    def setFunctionParameters(self, xsize, ysize, zsize, values): ...

class DrudeForce(Force):
    def __init__(self) -> None: ...
    def addParticle(
        self,
        particle: int,
        particle1: int,
        particle2: int,
        particle3: int,
        particle4: int,
        charge: float,
        polarizability: float,
        aniso12: float,
        aniso34: float,
    ) -> int: ...
    def addScreenedPair(self, particle1: int, particle2: int, thole: float) -> int: ...
    def getNumParticles(self) -> int: ...
    def getNumScreenedPairs(self) -> int: ...
    def getParticleParameters(
        self, index: int
    ) -> Tuple[int, int, int, int, int, float, float, float, float]: ...
    def getScreenedPairParameters(self, index: int) -> Tuple[int, int, float]: ...
    def setParticleParameters(
        self,
        index: int,
        particle: int,
        particle1: int,
        particle2: int,
        particle3: int,
        particle4: int,
        charge: float,
        polarizability: float,
        aniso12: float,
        aniso34: float,
    ) -> None: ...
    def setScreenedPairParameters(
        self, index: int, particle1: int, particle2: int, thole: float
    ) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class DrudeIntegrator(Integrator):
    def __init__(self, stepSize: float, /) -> None: ...
    def getDrudeTemperature(self) -> float: ...
    def getMaxDrudeDistance(self) -> float: ...
    def getRandomNumberSeed(self) -> int: ...
    def setDrudeTemperature(self, temp: float) -> None: ...
    def setMaxDrudeDistance(self, distance: float) -> None: ...
    def setRandomNumberSeed(self, seed: int) -> None: ...

class DrudeLangevinIntegrator(DrudeIntegrator):
    def __init__(
        self,
        temperature: float,
        frictionCoeff: float,
        drudeTemperature: float,
        drudeFrictionCoeff: float,
        stepSize: float,
        /,
    ) -> None: ...
    def getDrudeFriction(self) -> float: ...
    def getFriction(self) -> float: ...
    def getTemperature(self) -> float: ...
    def setDrudeFriction(self, coeff: float) -> None: ...
    def setFriction(self, coeff: float) -> None: ...
    def setTemperature(self, temp: float) -> None: ...

class NoseHooverIntegrator(Integrator):
    def __init__(
        self,
        temperature: float,
        collisionFrequency: float,
        stepSize: float,
        chainLength: int,
        numMTS: int,
        numYoshidaSuzuki: int,
        /,
    ) -> None: ...
    def addSubsystemThermostat(
        self,
        thermostatedParticles: Sequence[int],
        thermostatedPairs: Sequence[Sequence[int]],
        temperature: float,
        collisionFrequency: float,
        relativeTemperature: float,
        relativeCollisionFrequency: float,
        chainLength: int = ...,
        numMTS: int = ...,
        numYoshidaSuzuki: int = ...,
    ) -> None: ...
    def addThermostat(
        self,
        temperature: float,
        collisionFrequency: float,
        chainLength: int,
        numMTS: int,
        numYoshidaSuzuki: int,
    ) -> int: ...
    def computeHeatBathEnergy(self) -> float: ...
    def getCollisionFrequency(self, chainID: int = ...) -> float: ...
    def getMaximumPairDistance(self) -> float: ...
    def getNumThermostats(self) -> int: ...
    def getRelativeCollisionFrequency(self, chainID: int = ...) -> float: ...
    def getRelativeTemperature(self, chainID: int = ...) -> float: ...
    def getTemperature(self, chainID: int = ...) -> float: ...
    def getThermostat(self, chainID: int = ...) -> NoseHooverChain: ...
    def hasSubsystemThermostats(self) -> bool: ...
    def setCollisionFrequency(self, frequency: float, chainID: int = ...) -> None: ...
    def setMaximumPairDistance(self, distance) -> None: ...
    def setRelativeCollisionFrequency(
        self, frequency: float, chainID: int = ...
    ) -> None: ...
    def setRelativeTemperature(
        self, temperature: float, chainID: int = ...
    ) -> None: ...
    def setTemperature(self, temperature: float, chainID: int = ...) -> None: ...

class DrudeNoseHooverIntegrator(NoseHooverIntegrator):
    def __init__(
        self,
        temperature: float,
        collisionFrequency: float,
        drudeTemperature: float,
        drudeCollisionFrequency: float,
        stepSize: float,
        chainLength: int,
        numMTS: int,
        numYoshidaSuzuki: int,
        /,
    ) -> None: ...
    def computeDrudeKineticEnergy(self) -> float: ...
    def computeTotalKineticEnergy(self) -> float: ...
    def getMaxDrudeDistance(self) -> float: ...
    def getVelocitiesForTemperature(
        self, system: System, temperature: float, randomSeed: int
    ) -> Sequence[Vec3]: ...
    def initialize(self, context) -> None: ...
    def setMaxDrudeDistance(self, distance) -> None: ...

class DrudeSCFIntegrator(DrudeIntegrator):
    def __init__(self, stepSize: float, /) -> None: ...
    def getMinimizationErrorTolerance(self) -> float: ...
    def setMinimizationErrorTolerance(self, tol: float) -> None: ...

class GayBerneForce(Force):
    NonbondedMethod = NewType("NonbondedMethod", int)
    NoCutoff: NonbondedMethod
    CutoffNonPeriodic: NonbondedMethod
    CutoffPeriodic: NonbondedMethod
    def __init__(self) -> None: ...
    def addException(
        self,
        particle1: int,
        particle2: int,
        sigma: float,
        epsilon: float,
        replace: bool = ...,
    ) -> int: ...
    def addParticle(
        self,
        sigma: float,
        epsilon: float,
        xparticle: int,
        yparticle: int,
        sx: float,
        sy: float,
        sz: float,
        ex: float,
        ey: float,
        ez: float,
    ) -> int: ...
    def getCutoffDistance(self) -> float: ...
    def getExceptionParameters(self, index: int) -> Tuple[int, int, float, float]: ...
    def getNonbondedMethod(self) -> NonbondedMethod: ...
    def getNumExceptions(self) -> int: ...
    def getNumParticles(self) -> int: ...
    def getParticleParameters(
        self, index: int
    ) -> Tuple[float, float, int, int, float, float, float, float, float, float]: ...
    def getSwitchingDistance(self) -> float: ...
    def getUseSwitchingFunction(self) -> bool: ...
    def setCutoffDistance(self, distance: float) -> None: ...
    def setExceptionParameters(
        self, index: int, particle1: int, particle2: int, sigma: float, epsilon: float
    ) -> None: ...
    def setNonbondedMethod(self, method) -> None: ...
    def setParticleParameters(
        self,
        index: int,
        sigma: float,
        epsilon: float,
        xparticle: int,
        yparticle: int,
        sx: float,
        sy: float,
        sz: float,
        ex: float,
        ey: float,
        ez: float,
    ) -> None: ...
    def setSwitchingDistance(self, distance) -> None: ...
    def setUseSwitchingFunction(self, use) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class GBSAOBCForce(Force):
    NonbondedMethod = NewType("NonbondedMethod", int)
    NoCutoff: NonbondedMethod
    CutoffNonPeriodic: NonbondedMethod
    CutoffPeriodic: NonbondedMethod
    def __init__(self) -> None: ...
    def addParticle(
        self, charge: float, radius: float, scalingFactor: float
    ) -> int: ...
    def getCutoffDistance(self) -> float: ...
    def getNonbondedMethod(self) -> NonbondedMethod: ...
    def getNumParticles(self) -> int: ...
    def getParticleParameters(self, index: int) -> Tuple[float, float, float]: ...
    def getSoluteDielectric(self) -> float: ...
    def getSolventDielectric(self) -> float: ...
    def getSurfaceAreaEnergy(self) -> float: ...
    def setCutoffDistance(self, distance: float) -> None: ...
    def setNonbondedMethod(self, method) -> None: ...
    def setParticleParameters(
        self, index: int, charge: float, radius: float, scalingFactor: float
    ) -> None: ...
    def setSoluteDielectric(self, dielectric) -> None: ...
    def setSolventDielectric(self, dielectric) -> None: ...
    def setSurfaceAreaEnergy(self, energy) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class HarmonicAngleForce(Force):
    def __init__(self) -> None: ...
    def addAngle(
        self, particle1: int, particle2: int, particle3: int, angle: float, k: float
    ) -> int: ...
    def getAngleParameters(self, index: int) -> Tuple[int, int, int, float, float]: ...
    def getNumAngles(self) -> int: ...
    def setAngleParameters(
        self,
        index: int,
        particle1: int,
        particle2: int,
        particle3: int,
        angle: float,
        k: float,
    ) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class HarmonicBondForce(Force):
    def __init__(self) -> None: ...
    def addBond(
        self, particle1: int, particle2: int, length: float, k: float
    ) -> int: ...
    def getBondParameters(self, index: int) -> Tuple[int, int, float, float]: ...
    def getNumBonds(self) -> int: ...
    def setBondParameters(
        self, index: int, particle1: int, particle2: int, length: float, k: float
    ) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class HippoNonbondedForce(Force):
    NonbondedMethod = NewType("NonbondedMethod", int)
    NoCutoff: NonbondedMethod
    PME: NonbondedMethod
    def __init__(self) -> None: ...
    def addException(
        self,
        particle1: int,
        particle2: int,
        multipoleMultipoleScale: float,
        dipoleMultipoleScale: float,
        dipoleDipoleScale: float,
        dispersionScale: float,
        repulsionScale: float,
        chargeTransferScale: float,
        replace: bool = ...,
    ) -> int: ...
    def addParticle(
        self,
        charge: float,
        dipole: Sequence[float],
        quadrupole: Sequence[float],
        coreCharge: float,
        alpha: float,
        epsilon: float,
        damping: float,
        c6: float,
        pauliK: float,
        pauliQ: float,
        pauliAlpha: float,
        polarizability: float,
        axisType: int,
        multipoleAtomZ: int,
        multipoleAtomX: int,
        multipoleAtomY: int,
    ) -> int: ...
    def getCutoffDistance(self) -> float: ...
    def getDPMEParameters(self) -> Tuple[float, int, int, int]: ...
    def getDPMEParametersInContext(
        self, context: Context
    ) -> Tuple[float, int, int, int]: ...
    def getEwaldErrorTolerance(self) -> float: ...
    def getExceptionParameters(self, index: int) -> None: ...
    def getExtrapolationCoefficients(self) -> Sequence[float]: ...
    def getInducedDipoles(self, context: Context) -> Sequence[Vec3]: ...
    def getLabFramePermanentDipoles(self, context: Context) -> Sequence[Vec3]: ...
    def getNonbondedMethod(self) -> NonbondedMethod: ...
    def getNumExceptions(self) -> int: ...
    def getNumParticles(self) -> int: ...
    def getPMEParameters(self) -> Tuple[float, int, int, int]: ...
    def getPMEParametersInContext(
        self, context: Context
    ) -> Tuple[float, int, int, int]: ...
    def getParticleParameters(self, index: int) -> None: ...
    def getSwitchingDistance(self) -> float: ...
    def setCutoffDistance(self, distance: float) -> None: ...
    def setDPMEParameters(self, alpha: float, nx: int, ny: int, nz: int) -> None: ...
    def setEwaldErrorTolerance(self, tol) -> None: ...
    def setExceptionParameters(
        self,
        index: int,
        particle1: int,
        particle2: int,
        multipoleMultipoleScale: float,
        dipoleMultipoleScale: float,
        dipoleDipoleScale: float,
        dispersionScale: float,
        repulsionScale: float,
        chargeTransferScale: float,
    ) -> None: ...
    def setExtrapolationCoefficients(self, coefficients: Sequence[float]) -> None: ...
    def setNonbondedMethod(self, method) -> None: ...
    def setPMEParameters(self, alpha: float, nx: int, ny: int, nz: int) -> None: ...
    def setParticleParameters(
        self,
        index: int,
        charge: float,
        dipole: Sequence[float],
        quadrupole: Sequence[float],
        coreCharge: float,
        alpha: float,
        epsilon: float,
        damping: float,
        c6: float,
        pauliK: float,
        pauliQ: float,
        pauliAlpha: float,
        polarizability: float,
        axisType: int,
        multipoleAtomZ: int,
        multipoleAtomX: int,
        multipoleAtomY: int,
    ) -> None: ...
    def setSwitchingDistance(self, distance) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class LangevinIntegrator(Integrator):
    def __init__(
        self,
        temperature: Union[float, Quantity[float]],
        frictionCoeff: Union[float, Quantity[float]],
        stepSize: Union[float, Quantity[float]],
        /,
    ) -> None: ...
    def getFriction(self) -> Quantity[float]: ...
    def getRandomNumberSeed(self) -> int: ...
    def getTemperature(self) -> Quantity[float]: ...
    def setFriction(self, coeff: Union[float, Quantity[float]]) -> None: ...
    def setRandomNumberSeed(self, seed) -> None: ...
    def setTemperature(self, temp: float) -> None: ...

class LangevinMiddleIntegrator(Integrator):
    def __init__(
        self, temperature: float, frictionCoeff: float, stepSize: float, /
    ) -> None: ...
    def getFriction(self) -> float: ...
    def getRandomNumberSeed(self) -> int: ...
    def getTemperature(self) -> float: ...
    def setFriction(self, coeff: float) -> None: ...
    def setRandomNumberSeed(self, seed) -> None: ...
    def setTemperature(self, temp: float) -> None: ...

class VirtualSite:
    def getNumParticles(self) -> int: ...
    def getParticle(self, particle: int) -> int: ...

class LocalCoordinatesSite(VirtualSite):
    def __init__(
        self,
        particle1: int,
        particle2: int,
        particle3: int,
        originWeights: Vec3,
        xWeights: Vec3,
        yWeights: Vec3,
        localPosition: Vec3,
        /,
    ) -> None: ...
    def getLocalPosition(self) -> Vec3: ...
    def getOriginWeights(self) -> None: ...
    def getXWeights(self) -> None: ...
    def getYWeights(self) -> None: ...

class CMAPTorsionForce(Force):
    def __init__(self) -> None: ...
    def addMap(self, size: int, energy: Sequence[float]) -> int: ...
    def addTorsion(
        self,
        map: int,
        a1: int,
        a2: int,
        a3: int,
        a4: int,
        b1: int,
        b2: int,
        b3: int,
        b4: int,
    ) -> int: ...
    def getMapParameters(self, index: int) -> Tuple[int, Quantity[Sequence[float]]]: ...
    def getNumMaps(self) -> int: ...
    def getNumTorsions(self) -> int: ...
    def getTorsionParameters(
        self, index: int
    ) -> Tuple[int, int, int, int, int, int, int, int, int]: ...
    def setMapParameters(
        self, index: int, size: int, energy: Quantity[Sequence[float]]
    ) -> None: ...
    def setTorsionParameters(
        self,
        index: int,
        map: int,
        a1: int,
        a2: int,
        a3: int,
        a4: int,
        b1: int,
        b2: int,
        b3: int,
        b4: int,
    ) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class LocalEnergyMinimizer:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def minimize(
        context: Context, tolerance: float = ..., maxIterations: int = ...
    ) -> None: ...

class MonteCarloAnisotropicBarostat(Force):
    @staticmethod
    def PressureX() -> None: ...
    @staticmethod
    def PressureY() -> None: ...
    @staticmethod
    def PressureZ() -> None: ...
    @staticmethod
    def Temperature() -> None: ...
    def __init__(
        self,
        defaultPressure: Vec3,
        defaultTemperature: float,
        scaleX: bool,
        scaleY: bool,
        scaleZ: bool,
        frequency: int,
        /,
    ) -> None: ...
    def getDefaultPressure(self) -> Vec3: ...
    def getDefaultTemperature(self) -> float: ...
    def getFrequency(self) -> int: ...
    def getRandomNumberSeed(self) -> int: ...
    def getScaleX(self) -> bool: ...
    def getScaleY(self) -> bool: ...
    def getScaleZ(self) -> bool: ...
    def setDefaultPressure(self, pressure: Vec3) -> None: ...
    def setDefaultTemperature(self, temp: float) -> None: ...
    def setFrequency(self, freq) -> None: ...
    def setRandomNumberSeed(self, seed) -> None: ...

class MonteCarloBarostat(Force):
    @staticmethod
    def Pressure() -> None: ...
    @staticmethod
    def Temperature() -> None: ...
    def __init__(
        self, defaultPressure: float, defaultTemperature: float, frequency: int, /
    ) -> None: ...
    def getDefaultPressure(self) -> float: ...
    def getDefaultTemperature(self) -> float: ...
    def getFrequency(self) -> int: ...
    def getRandomNumberSeed(self) -> int: ...
    def setDefaultPressure(self, pressure: float) -> None: ...
    def setDefaultTemperature(self, temp: float) -> None: ...
    def setFrequency(self, freq) -> None: ...
    def setRandomNumberSeed(self, seed) -> None: ...

def MonteCarloBarostat_Pressure(): ...
def MonteCarloBarostat_Temperature(): ...

class MonteCarloMembraneBarostat(Force):
    XYMode = NewType("XYMode", int)
    ZMode = NewType("ZMode", int)
    XYIsotropic: XYMode
    XYAnisotropic: XYMode
    ZFree: ZMode
    ZFixed: ZMode
    ConstantVolume: ZMode
    @staticmethod
    def Pressure() -> str: ...
    @staticmethod
    def SurfaceTension() -> str: ...
    @staticmethod
    def Temperature() -> str: ...
    def __init__(
        self,
        defaultPressure: float,
        defaultSurfaceTension: float,
        defaultTemperature: float,
        xymode: XYMode,
        zmode: ZMode,
        frequency: int,
        /,
    ) -> None: ...
    def getDefaultPressure(self) -> float: ...
    def getDefaultSurfaceTension(self) -> float: ...
    def getDefaultTemperature(self) -> float: ...
    def getFrequency(self) -> int: ...
    def getRandomNumberSeed(self) -> int: ...
    def getXYMode(self) -> XYMode: ...
    def getZMode(self) -> ZMode: ...
    def setDefaultPressure(self, pressure: float) -> None: ...
    def setDefaultSurfaceTension(self, surfaceTension: float) -> None: ...
    def setDefaultTemperature(self, temp: float) -> None: ...
    def setFrequency(self, freq) -> None: ...
    def setRandomNumberSeed(self, seed) -> None: ...
    def setXYMode(self, mode) -> None: ...
    def setZMode(self, mode) -> None: ...

class NonbondedForce(Force):
    NonbondedMethod = NewType("NonbondedMethod", int)
    NoCutoff: NonbondedMethod
    CutoffNonPeriodic: NonbondedMethod
    CutoffPeriodic: NonbondedMethod
    Ewald: NonbondedMethod
    PME: NonbondedMethod
    LJPME: NonbondedMethod
    def __init__(self) -> None: ...
    def addException(
        self,
        particle1: int,
        particle2: int,
        chargeProd: float,
        sigma: float,
        epsilon: float,
        replace: bool = ...,
    ) -> int: ...
    def addExceptionParameterOffset(
        self,
        parameter: str,
        exceptionIndex: int,
        chargeProdScale: float,
        sigmaScale: float,
        epsilonScale: float,
    ) -> int: ...
    def addException_usingRMin(
        self, particle1, particle2, chargeProd, rMin, epsilon
    ) -> None: ...
    def addGlobalParameter(self, name: str, defaultValue: float) -> int: ...
    def addParticle(self, charge: float, sigma: float, epsilon: float) -> int: ...
    def addParticleParameterOffset(
        self,
        parameter: str,
        particleIndex: int,
        chargeScale: float,
        sigmaScale: float,
        epsilonScale: float,
    ) -> int: ...
    def addParticle_usingRVdw(self, charge, rVDW, epsilon) -> None: ...
    def createExceptionsFromBonds(
        self, bonds: Sequence[Sequence[int]], coulomb14Scale: float, lj14Scale: float
    ) -> None: ...
    def getCutoffDistance(self) -> float: ...
    def getEwaldErrorTolerance(self) -> float: ...
    def getExceptionParameterOffset(self, index: int) -> None: ...
    def getExceptionParameters(
        self, index: int
    ) -> Tuple[int, int, float, float, float]: ...
    def getExceptionsUsePeriodicBoundaryConditions(self) -> bool: ...
    def getGlobalParameterDefaultValue(self, index: int) -> float: ...
    def getGlobalParameterName(self, index: int) -> str: ...
    def getIncludeDirectSpace(self) -> bool: ...
    def getLJPMEParameters(self) -> Tuple[float, int, int, int]: ...
    def getLJPMEParametersInContext(
        self, context: Context
    ) -> Tuple[float, int, int, int]: ...
    def getNonbondedMethod(self) -> NonbondedMethod: ...
    def getNumExceptionParameterOffsets(self) -> int: ...
    def getNumExceptions(self) -> int: ...
    def getNumGlobalParameters(self) -> int: ...
    def getNumParticleParameterOffsets(self) -> int: ...
    def getNumParticles(self) -> int: ...
    def getPMEParameters(self) -> Tuple[float, int, int, int]: ...
    def getPMEParametersInContext(
        self, context: Context
    ) -> Tuple[float, int, int, int]: ...
    def getParticleParameterOffset(self, index: int) -> None: ...
    def getParticleParameters(self, index: int) -> Tuple[float, float, float]: ...
    def getReactionFieldDielectric(self) -> float: ...
    def getReciprocalSpaceForceGroup(self) -> int: ...
    def getSwitchingDistance(self) -> float: ...
    def getUseDispersionCorrection(self) -> bool: ...
    def getUseSwitchingFunction(self) -> bool: ...
    def setCutoffDistance(self, distance: float) -> None: ...
    def setEwaldErrorTolerance(self, tol) -> None: ...
    def setExceptionParameterOffset(
        self,
        index: int,
        parameter: str,
        exceptionIndex: int,
        chargeProdScale: float,
        sigmaScale: float,
        epsilonScale: float,
    ) -> None: ...
    def setExceptionParameters(
        self,
        index: int,
        particle1: int,
        particle2: int,
        chargeProd: float,
        sigma: float,
        epsilon: float,
    ) -> None: ...
    def setExceptionsUsePeriodicBoundaryConditions(self, periodic) -> None: ...
    def setGlobalParameterDefaultValue(
        self, index: int, defaultValue: float
    ) -> None: ...
    def setGlobalParameterName(self, index: int, name: str) -> None: ...
    def setIncludeDirectSpace(self, include) -> None: ...
    def setLJPMEParameters(self, alpha: float, nx: int, ny: int, nz: int) -> None: ...
    def setNonbondedMethod(self, method) -> None: ...
    def setPMEParameters(self, alpha: float, nx: int, ny: int, nz: int) -> None: ...
    def setParticleParameterOffset(
        self,
        index: int,
        parameter: str,
        particleIndex: int,
        chargeScale: float,
        sigmaScale: float,
        epsilonScale: float,
    ) -> None: ...
    def setParticleParameters(
        self, index: int, charge: float, sigma: float, epsilon: float
    ) -> None: ...
    def setReactionFieldDielectric(self, dielectric) -> None: ...
    def setReciprocalSpaceForceGroup(self, group: int) -> None: ...
    def setSwitchingDistance(self, distance) -> None: ...
    def setUseDispersionCorrection(self, useCorrection) -> None: ...
    def setUseSwitchingFunction(self, use) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class NoseHooverChain:
    def __init__(
        self,
        temperature: float,
        collisionFrequency: float,
        relativeTemperature: float,
        relativeCollisionFrequency: float,
        numDOFs: int,
        chainLength: int,
        numMTS: int,
        numYoshidaSuzuki: int,
        chainID: int,
        thermostatedAtoms: Sequence[int],
        thermostatedPairs: Sequence[Sequence[int]],
        /,
    ) -> None: ...
    def getChainID(self) -> int: ...
    def getChainLength(self) -> int: ...
    def getCollisionFrequency(self) -> float: ...
    def getNumDegreesOfFreedom(self) -> int: ...
    def getNumMultiTimeSteps(self) -> int: ...
    def getNumYoshidaSuzukiTimeSteps(self) -> int: ...
    def getRelativeCollisionFrequency(self) -> float: ...
    def getRelativeTemperature(self) -> float: ...
    def getTemperature(self) -> float: ...
    def getThermostatedAtoms(self) -> Sequence[int]: ...
    def getThermostatedPairs(self) -> Sequence[Sequence[int]]: ...
    def getYoshidaSuzukiWeights(self) -> Sequence[float]: ...
    def setCollisionFrequency(self, frequency: float) -> None: ...
    def setNumDegreesOfFreedom(self, numDOF: int) -> None: ...
    def setRelativeCollisionFrequency(self, frequency: float) -> None: ...
    def setRelativeTemperature(self, temperature: float) -> None: ...
    def setTemperature(self, temperature: float) -> None: ...
    def setThermostatedAtoms(self, atomIDs: Sequence[int]) -> None: ...
    def setThermostatedPairs(self, pairIDs: Sequence[Sequence[int]]) -> None: ...
    def usesPeriodicBoundaryConditions(self) -> bool: ...

class OutOfPlaneSite(VirtualSite):
    def __init__(
        self,
        particle1: int,
        particle2: int,
        particle3: int,
        weight12: float,
        weight13: float,
        weightCross: float,
        /,
    ) -> None: ...
    def getWeight12(self) -> float: ...
    def getWeight13(self) -> float: ...
    def getWeightCross(self) -> float: ...

class PeriodicTorsionForce(Force):
    def __init__(self) -> None: ...
    def addTorsion(
        self,
        particle1: int,
        particle2: int,
        particle3: int,
        particle4: int,
        periodicity: int,
        phase: float,
        k: float,
    ) -> int: ...
    def getNumTorsions(self) -> int: ...
    def getTorsionParameters(
        self, index: int
    ) -> Tuple[int, int, int, int, int, float, float]: ...
    def setTorsionParameters(
        self,
        index: int,
        particle1: int,
        particle2: int,
        particle3: int,
        particle4: int,
        periodicity: int,
        phase: float,
        k: float,
    ) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class Platform:
    def __init__(self, *args, **kwargs) -> None: ...
    @staticmethod
    def findPlatform(kernelNames: Sequence[str]) -> Platform: ...
    @staticmethod
    def getDefaultPluginsDirectory() -> str: ...
    def getName(self) -> str: ...
    @staticmethod
    def getNumPlatforms() -> None: ...
    @staticmethod
    def getOpenMMVersion() -> None: ...
    @staticmethod
    def getPlatform(index) -> Platform: ...
    @staticmethod
    def getPlatformByName(name) -> Platform: ...
    @staticmethod
    def getPluginLoadFailures() -> None: ...
    def getPropertyDefaultValue(self, property: str) -> str: ...
    def getPropertyNames(self) -> Sequence[str]: ...
    def getPropertyValue(self, context: Context, property: str) -> str: ...
    def getSpeed(self) -> float: ...
    def linkedContextCreated(self, context: Any, originalContext: Any) -> None: ...
    @staticmethod
    def loadPluginLibrary(file: str) -> None: ...
    @staticmethod
    def loadPluginsFromDirectory(directory: str) -> Sequence[str]: ...
    @staticmethod
    def registerPlatform(platform) -> None: ...
    def setPropertyDefaultValue(self, property: str, value: str) -> None: ...
    def setPropertyValue(self, context: Context, property: str, value: str) -> None: ...
    def supportsDoublePrecision(self) -> bool: ...
    def supportsKernels(self, kernelNames: Sequence[str]) -> bool: ...

class RBTorsionForce(Force):
    def __init__(self) -> None: ...
    def addTorsion(
        self,
        particle1: int,
        particle2: int,
        particle3: int,
        particle4: int,
        c0: float,
        c1: float,
        c2: float,
        c3: float,
        c4: float,
        c5: float,
    ) -> int: ...
    def getNumTorsions(self) -> int: ...
    def getTorsionParameters(
        self, index: int
    ) -> Tuple[int, int, int, int, float, float, float, float, float, float]: ...
    def setTorsionParameters(
        self,
        index: int,
        particle1: int,
        particle2: int,
        particle3: int,
        particle4: int,
        c0: float,
        c1: float,
        c2: float,
        c3: float,
        c4: float,
        c5: float,
    ) -> None: ...
    def setUsesPeriodicBoundaryConditions(self, periodic) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class RMSDForce(Force):
    def __init__(
        self, referencePositions: Sequence[Vec3], particles: Sequence[int], /
    ) -> None: ...
    def getParticles(self) -> Sequence[int]: ...
    def getReferencePositions(self) -> Sequence[Vec3]: ...
    def setParticles(self, particles) -> None: ...
    def setReferencePositions(self, positions) -> None: ...
    def updateParametersInContext(self, context) -> None: ...

class RPMDIntegrator(Integrator):
    def __init__(
        self,
        numCopies: int,
        temperature: float,
        frictionCoeff: float,
        stepSize: float,
        contractions: Mapping[int, int],
        /,
    ) -> None: ...
    def getApplyThermostat(self) -> bool: ...
    def getContractions(self) -> Mapping[int, int]: ...
    def getFriction(self) -> float: ...
    def getNumCopies(self) -> int: ...
    def getRandomNumberSeed(self) -> int: ...
    def getState(
        self,
        copy: int,
        getPositions=...,
        getVelocities=...,
        getForces=...,
        getEnergy=...,
        getParameters=...,
        getParameterDerivatives=...,
        enforcePeriodicBox=...,
        groups=...,
    ) -> None: ...
    def getTemperature(self) -> float: ...
    def getTotalEnergy(self) -> float: ...
    def setApplyThermostat(self, apply) -> None: ...
    def setFriction(self, coeff: float) -> None: ...
    def setPositions(self, copy: int, positions: Sequence[Vec3]) -> None: ...
    def setRandomNumberSeed(self, seed) -> None: ...
    def setTemperature(self, temp: float) -> None: ...
    def setVelocities(self, copy: int, velocities: Sequence[Vec3]) -> None: ...

class RPMDMonteCarloBarostat(Force):
    @staticmethod
    def Pressure() -> None: ...
    def __init__(self, defaultPressure: float, frequency: int, /) -> None: ...
    def getDefaultPressure(self) -> float: ...
    def getFrequency(self) -> int: ...
    def getRandomNumberSeed(self) -> int: ...
    def setDefaultPressure(self, pressure: float) -> None: ...
    def setFrequency(self, freq) -> None: ...
    def setRandomNumberSeed(self, seed) -> None: ...

class SerializationNode:
    def __init__(self, *args, **kwargs) -> None: ...
    def createChildNode(self, name: str) -> SerializationNode: ...
    def getBoolProperty(self, name: str, defaultValue: bool, /) -> bool: ...
    def getChildNode(self, the: str, /) -> SerializationNode: ...
    def getChildren(self) -> Sequence[SerializationNode]: ...
    def getDoubleProperty(self, name: str, defaultValue: float, /) -> float: ...
    def getIntProperty(self, name: str, defaultValue: int, /) -> int: ...
    def getName(self) -> str: ...
    def getProperties(self) -> Mapping[str, str]: ...
    def getStringProperty(self, name: str, defaultValue: str, /) -> str: ...
    def hasProperty(self, name: str) -> bool: ...
    def setBoolProperty(self, name: str, value: bool) -> SerializationNode: ...
    def setDoubleProperty(self, name: str, value: float) -> SerializationNode: ...
    def setIntProperty(self, name: str, value: int) -> SerializationNode: ...
    def setName(self, name: str) -> None: ...
    def setStringProperty(self, name: str, value: str) -> SerializationNode: ...

class SerializationProxy:
    def __init__(self, *args, **kwargs) -> None: ...
    def deserialize(self, node: SerializationNode) -> None: ...
    def getProxy(*args) -> SerializationProxy: ...
    def getTypeName(self) -> str: ...
    @staticmethod
    def registerProxy(type: str, proxy: SerializationProxy) -> None: ...
    def serialize(self, object: None, node: SerializationNode) -> None: ...

class State:
    def __init__(self) -> None: ...
    @overload
    def getForces(self, asNumpy: Literal[True]) -> Quantity[np.ndarray]: ...
    @overload
    def getForces(self, asNumpy: Literal[False]) -> Quantity[Sequence[Vec3]]: ...
    @overload
    def getForces(
        self, asNumpy: bool = ...
    ) -> Union[Quantity[np.ndarray], Quantity[Sequence[Vec3]]]: ...
    def getPotentialEnergy(self) -> Quantity[float]: ...
    def getKineticEnergy(self) -> Quantity[float]: ...
    @overload
    def getPositions(self, asNumpy: Literal[True]) -> Quantity[np.ndarray]: ...
    @overload
    def getPositions(self, asNumpy: Literal[False]) -> Quantity[Sequence[Vec3]]: ...
    @overload
    def getPositions(
        self, asNumpy: bool = ...
    ) -> Union[Quantity[np.ndarray], Quantity[Sequence[Vec3]]]: ...
    @overload
    def getVelocities(self, asNumpy: Literal[True]) -> Quantity[np.ndarray]: ...
    @overload
    def getVelocities(self, asNumpy: Literal[False]) -> Quantity[Sequence[Vec3]]: ...
    @overload
    def getVelocities(
        self, asNumpy: bool = ...
    ) -> Union[Quantity[np.ndarray], Quantity[Sequence[Vec3]]]: ...
    def getPeriodicBoxVectors(self) -> Quantity[Sequence[Vec3]]: ...
    def getDataTypes(self) -> int: ...
    def getEnergyParameterDerivatives(self) -> Mapping[str, float]: ...
    def getParameters(self) -> Mapping[str, float]: ...
    def getPeriodicBoxVolume(self) -> float: ...
    def getTime(self) -> float: ...

class System:
    def __init__(self) -> None: ...
    def addConstraint(self, particle1: int, particle2: int, distance: float) -> int: ...
    def addForce(self, force: Force) -> int: ...
    def addParticle(self, mass: Union[float, Quantity[float]]) -> int: ...
    def getConstraintParameters(self, index: int) -> Tuple[int, int, float]: ...
    def getDefaultPeriodicBoxVectors(self) -> Tuple[Vec3, Vec3, Vec3]: ...
    def getForce(self, index: int, /) -> Force: ...
    def getForces(self) -> Sequence[Force]: ...
    def getNumConstraints(self) -> int: ...
    def getNumForces(self) -> int: ...
    def getNumParticles(self) -> int: ...
    def getParticleMass(self, index: int) -> Quantity[float]: ...
    def getVirtualSite(self, index: int) -> VirtualSite: ...
    def isVirtualSite(self, index: int) -> bool: ...
    def removeConstraint(self, index: int) -> None: ...
    def removeForce(self, index: int) -> None: ...
    def setConstraintParameters(
        self, index: int, particle1: int, particle2: int, distance: float
    ) -> None: ...
    def setDefaultPeriodicBoxVectors(self, a: Vec3, b: Vec3, c: Vec3) -> None: ...
    def setParticleMass(self, index: int, mass: float) -> None: ...
    def setVirtualSite(self, index: int, virtualSite: VirtualSite) -> None: ...
    def usesPeriodicBoundaryConditions(self) -> bool: ...

class ThreeParticleAverageSite(VirtualSite):
    def __init__(
        self,
        particle1: int,
        particle2: int,
        particle3: int,
        weight1: float,
        weight2: float,
        weight3: float,
        /,
    ) -> None: ...
    def getWeight(self, particle: int) -> float: ...

class TwoParticleAverageSite(VirtualSite):
    def __init__(
        self, particle1: int, particle2: int, weight1: float, weight2: float, /
    ) -> None: ...
    def getWeight(self, particle: int) -> float: ...

class VariableLangevinIntegrator(Integrator):
    def __init__(
        self, temperature: float, frictionCoeff: float, errorTol: float, /
    ) -> None: ...
    def getErrorTolerance(self) -> float: ...
    def getFriction(self) -> float: ...
    def getMaximumStepSize(self) -> float: ...
    def getRandomNumberSeed(self) -> int: ...
    def getTemperature(self) -> float: ...
    def setErrorTolerance(self, tol) -> None: ...
    def setFriction(self, coeff: float) -> None: ...
    def setMaximumStepSize(self, size) -> None: ...
    def setRandomNumberSeed(self, seed) -> None: ...
    def setTemperature(self, temp: float) -> None: ...
    def stepTo(self, time: float) -> None: ...

class VariableVerletIntegrator(Integrator):
    def __init__(self, errorTol: float, /) -> None: ...
    def getErrorTolerance(self) -> float: ...
    def getMaximumStepSize(self) -> float: ...
    def setErrorTolerance(self, tol) -> None: ...
    def setMaximumStepSize(self, size) -> None: ...
    def stepTo(self, time: float) -> None: ...

class VerletIntegrator(Integrator):
    def __init__(self, stepSize: float, /) -> None: ...

class XmlSerializer:
    @staticmethod
    def deserialize(inputString) -> None: ...
    @staticmethod
    def deserializeSystem(inputString) -> System: ...
    @staticmethod
    def serialize(object) -> str: ...
    @staticmethod
    def serializeSystem(object) -> str: ...
