from __future__ import annotations

import dataclasses
from typing import Any, List, Optional, Tuple, Union

import numpy as np
from ase.geometry import find_mic

from narupatools.frame import FrameData, convert, select
from narupatools.frame.fields import BoxVectors, ParticleCharges, ParticlePositions
from narupatools.physics.units import UnitsNarupa

from ._units import get_unit_system


@dataclasses.dataclass
class AtomType:
    """Atom type as defined in a LAMMPS data file."""

    data_file: LAMMPSDataFile
    type: int
    name: str
    mass: float
    charge: Optional[float]


@dataclasses.dataclass
class AngleType:
    """Angle type as defined in a LAMMPS data file."""

    data_file: LAMMPSDataFile
    type: int
    name: str
    atoms: List[Tuple[int, int, int]] = dataclasses.field(default_factory=list)

    def add_atoms(self, atom1: str, atom2: str, atom3: str, cutoff: float) -> None:
        """Define sets of atoms to include in this angle type."""
        indices0 = self.data_file._select(atom1)
        indices1 = self.data_file._select(atom2)
        indices2 = self.data_file._select(atom3)
        for j in indices1:
            for i in indices0:
                if i == j:
                    continue
                if self.data_file.distance(i, j) > cutoff:
                    continue
                for k in indices2:
                    if k in [i, j]:
                        continue
                    if self.data_file.distance(j, k) > cutoff:
                        continue
                    angle = (i, j, k)
                    if (k, j, i) not in self.atoms:
                        self.atoms.append(angle)


class LAMMPSDataFile:
    """LAMMPS data file generator."""

    def __init__(self, frame: Any, *, atom_style: str, periodic: bool, units: str):
        if not isinstance(frame, FrameData):
            frame = convert(frame, FrameData)
        self._frame = frame
        self._narupa_to_lammps = UnitsNarupa >> get_unit_system(units)
        self._count = len(self._frame[ParticlePositions])
        self._atom_type_assignments = np.empty(shape=(self._count,), dtype=object)
        self._atom_style = atom_style
        self._atom_types: List[AtomType] = []
        self._angle_types: List[AngleType] = []
        self._periodic = periodic
        self._units = units
        self._distances: Optional[np.ndarray] = None

    def distance(self, i: int, j: int) -> float:
        """Get the (periodic) distance between two atoms."""
        if self._distances is None:
            box = self._frame[BoxVectors] * self._narupa_to_lammps.length
            positions = self._frame[ParticlePositions] * self._narupa_to_lammps.length
            tris = np.triu_indices(len(positions))
            offsets = positions[tris[1]] - positions[tris[0]]
            self._distances = find_mic(offsets, box)[1]  # type: ignore
        if i <= j:
            return self._distances[(2 * self._count + 1 - i) * i // 2 + j - i]  # type: ignore
        else:
            return self._distances[(2 * self._count + 1 - j) * j // 2 + i - j]  # type: ignore

    def _select(self, arg: Union[str, AtomType], /) -> np.ndarray:
        if isinstance(arg, str):
            return select(self._frame, arg)
        else:
            return np.where(self._atom_type_assignments == arg)[0]  # type: ignore

    def output(self, *, comment: str) -> None:
        """Generate the data file."""
        if any(self._atom_type_assignments == 0):
            raise ValueError("Some atoms have not been allocated a type.")

        print(comment, "(Generated by narupatools)")
        print()

        print(self._count, "atoms")
        print(0, "bonds")
        print(sum(len(angle.atoms) for angle in self._angle_types), "angles")
        print(0, "dihedrals")
        print(0, "impropers")
        print()

        print(len(self._atom_types), "atom types")
        print(0, "bond types")
        print(len(self._angle_types), "angle types")
        print(0, "dihedral types")
        print(0, "improper types")
        print()

        box = self._frame[BoxVectors] * self._narupa_to_lammps.length
        print(0.0, box[0, 0], "xlo", "xhi")
        print(0.0, box[1, 1], "ylo", "yhi")
        print(0.0, box[2, 2], "zlo", "zhi")
        print()

        print("Masses")
        print()
        for atom_type in self._atom_types:
            print(atom_type.type, atom_type.mass, " #", atom_type.name)
        print()

        print(f"Atoms # {self._atom_style}")
        print()
        positions = self._frame[ParticlePositions] * self._narupa_to_lammps.length
        charges = self._frame[ParticleCharges]
        for i in range(self._count):
            position = positions[i]
            if self._atom_type_assignments[i].charge:
                charge = self._atom_type_assignments[i].charge
            else:
                charge = charges[i]
            if self._atom_style == "full":
                print(
                    i + 1,
                    1,
                    self._atom_type_assignments[i].type,
                    charge,
                    *position,
                    "  #",
                    self._atom_type_assignments[i].name,
                )
            else:
                raise ValueError(f"Cannot currently use atom_style {self._atom_style}")
        print()

        if self._angle_types:

            print("Angles")
            print()
            for angle_id, angle_type in enumerate(self._angle_types):
                for i, j, k in angle_type.atoms:
                    print(angle_id + 1, angle_type.type, i, j, k, " #", angle_type.name)
            print()

    def create_atom_type(
        self, *, name: str, atoms: str, mass: float, charge: Optional[float] = None
    ) -> AtomType:
        """Create a new atom type."""
        atom_type = AtomType(
            data_file=self,
            type=len(self._atom_types) + 1,
            name=name,
            mass=mass,
            charge=charge,
        )
        self._atom_types.append(atom_type)
        indices = select(self._frame, atoms)
        if len(indices) == 0:
            raise ValueError(f"No atoms match pattern {atoms}")
        for i in indices:
            self._atom_type_assignments[i] = atom_type
        return atom_type

    def create_angle_type(self, *, name: str) -> AngleType:
        """Create a new angle type."""
        angle_type = AngleType(
            data_file=self, type=len(self._angle_types) + 1, name=name
        )
        self._angle_types.append(angle_type)
        return angle_type
